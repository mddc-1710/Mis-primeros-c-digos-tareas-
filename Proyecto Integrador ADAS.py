# -*- coding: utf-8 -*-
"""Proyecto integrador ADAS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FzO2eM_zLT5n7KknPqEkoy0CRC_Tnp5P
"""

# Proyecto Integrador
# Este script implementa los fundamentos de detección de bordes
# descritos en el documento Proyecto_integrador
# Marcos Daniel Domínguez Contreras | A01662993
# Juan Heriberto Carmona Estrada |  A01826326

import math

SOBEL_H = [  # Gx (Gradiente en X, detecta bordes verticales)
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1]
]

SOBEL_V = [  # Gy (Gradiente en Y, detecta bordes horizontales)
    [-1, -2, -1],
    [ 0,  0,  0],
    [ 1,  2,  1]
]


def print_matrix(matrix):
    if not matrix:
        print("[]")
        return

    for row in matrix:
        # Imprimir cada elemento con un ancho fijo para alinear
        for val in row:
            # %8.2f = 8 caracteres de ancho con 2 decimales
            print(f"{val:8.2f}", end=" ")
        print()  # Nueva línea al final de la fila


def get_image_input():
    print("--- Ingrese la imagen 5x5 (píxeles 0-255) ---")
    image = []
    size = 5

    i = 0  # Índice de fila
    while i < size:
        row_input = input(f"Ingrese la fila {i+1} (5 números separados por coma): ")

        # Separamos la entrada por comas
        row_str = row_input.split(',')

        # 1. Validarmos que sean 5 elementos
        if len(row_str) != size:
            print(f"Error: Ingrese exactamente 5 números. Usted ingresó {len(row_str)}.")
            continue  # Volver a pedir la misma fila

        row_int = []
        valid_row = True


        j = 0  # Índice de columna
        while j < len(row_str):
            val_str = row_str[j].strip()
            try:
                # Validar que sea un entero
                val_int = int(val_str)

                # Validar rango 0-255
                if val_int < 0 or val_int > 255:
                    print(f"Error: El valor '{val_int}' está fuera del rango (0-255).")
                    valid_row = False
                    break

                row_int.append(val_int)
            except ValueError:
                print(f"Error: El valor '{val_str}' no es un entero válido.")
                valid_row = False
                break

            j += 1

        # Si la fila es completamente válida, se añade a la imagen
        if valid_row:
            image.append(row_int)
            i += 1  # Avanza a la siguiente fila

    return image


def convolve(image, kernel):
    # Dimensiones (asumimos kernel 3x3 e imagen 5x5 según las instrucciones)
    k_size = 3
    img_height = 5
    img_width = 5

    # La salida será 3x3 (5 - 3 + 1 = 3)
    output_size = 3

    # Inicializar la matriz de salida 3x3 con ceros
    output_matrix = []
    i_init = 0
    while i_init < output_size:
        # Añadir una fila de 3 ceros
        new_row = [0, 0, 0]
        output_matrix.append(new_row)
        i_init += 1

    # El bucle 'y' (filas) va del índice 1 al 3
    # El bucle 'x' (columnas) va del índice 1 al 3

    y = 1  # Fila central del kernel en la imagen
    while y <= (img_height - 2):  # y = 1, 2, 3
        x = 1  # Columna central del kernel en la imagen
        while x <= (img_width - 2):  # x = 1, 2, 3

            # Aplicar el kernel 3x3 centrado en (y, x)
            sum_val = 0

            ky = 0  # Fila del kernel
            while ky < k_size:  # ky = 0, 1, 2
                kx = 0  # Columna del kernel
                while kx < k_size:  # kx = 0, 1, 2

                    # Calcular la coordenada de la imagen correspondiente
                    # (ky - 1) y (kx - 1) nos da el offset: -1, 0, 1
                    img_y = y + (ky - 1)
                    img_x = x + (kx - 1)

                    kernel_val = kernel[ky][kx]
                    image_val = image[img_y][img_x]

                    sum_val += (kernel_val * image_val)

                    kx += 1
                ky += 1

            # Guardar el resultado en la matriz de salida
            # Mapear (y, x) [1,1] de la imagen al (0,0) de la salida
            output_y = y - 1
            output_x = x - 1
            output_matrix[output_y][output_x] = sum_val

            x += 1
        y += 1

    return output_matrix


def calculate_magnitude(grad_h, grad_v):
    size = 3
    magnitude_matrix = []

    # Inicializar matriz de salida 3x3 con ceros
    i = 0
    while i < size:
        new_row = [0.0, 0.0, 0.0]
        magnitude_matrix.append(new_row)
        i += 1

    y = 0
    while y < size:
        x = 0
        while x < size:
            h_val = grad_h[y][x]
            v_val = grad_v[y][x]

            # G = sqrt(Gx al cuadradp + Gy al cuadrado)
            magnitude = math.sqrt((h_val ** 2) + (v_val ** 2))

            magnitude_matrix[y][x] = magnitude
            x += 1
        y += 1

    return magnitude_matrix


def main():
    # 1. Entrada de matriz 5x5
    image = get_image_input()
    print("\n--- (1) Imagen Original 5x5 ---")
    print_matrix(image)

    # 2. Convolución Sobel H (Gx)
    print("\n--- (2.a) Convolución Sobel H (Gx) ---")
    grad_h = convolve(image, SOBEL_H)
    print_matrix(grad_h)

    # 3. Convolución Sobel V (Gy)
    print("\n--- (2.b) Convolución Sobel V (Gy) ---")
    grad_v = convolve(image, SOBEL_V)
    print_matrix(grad_v)

    # 4. Combinación (Magnitud)
    print("\n--- (3) Imagen Procesada (Magnitud del Gradiente) ---")
    magnitude_image = calculate_magnitude(grad_h, grad_v)
    print_matrix(magnitude_image)

if __name__ == "__main__":
    main()
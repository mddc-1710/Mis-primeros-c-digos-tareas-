# -*- coding: utf-8 -*-
"""Tarea4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YRQVoAzg50TBWs4F0IlQXOpAAInb-frQ
"""

# Tarea 4: Programas que utilizan listas
 # 1. Analizador de una lista entera (todo-en-uno de una sola lista)

# Leer n>0
while True:
    try:
        n = int(input('Introduce un entero n > 0: '))
        if n > 0:
            break
    except ValueError:
        print('Error, intente de nuevo')

# Capturar n enteros
lista = []
for i in range(n):
    while True:
        try:
            num = int(input(f'Introduce el entero {i + 1}/{n}: '))
            lista.append(num)
            break
        except ValueError:
            print('Error, intente de nuevo')

# Mostrar lista con √≠ndice creciente
for i in range(n):
    print(f'lista[{i}] = {lista[i]}')

# Mostrar lista con √≠ndices decreciente
for i in range(1, n + 1):
    print(f'lista[{-i}] = {lista[-i]}')

# Mostrar la lista
print(lista)

# Calcular y mostrar el promedio de la lisa
promedio = sum(lista) / n
print(f'el promedio de la lista es = {promedio:.2f}')

# Contar numeros pares e impares
pares_conteo = sum(1 for x in lista if x % 2 == 0)
impares_conteo = n - pares_conteo
print(f'numero de pares= {pares_conteo}')
print(f'numero de impares= {impares_conteo}')

# Mostrar la lista al cuadrado
cuadrados = [x**2 for x in lista]
print(f'lista de cuadrados {cuadrados}')

# Mostrar la sublista de pares
pares_lista = [x for x in lista if x % 2 == 0]
print(f'lista de pares {pares_lista}')

# Mostrar la sublista de impares
impares_lista = [x for x in lista if x % 2 != 0]
print(f'lista de impares {impares_lista}')

# Mostrar los valores menores que su siguiente
print('numeros menores que el siguiente')
for i in range(n - 1):
    if lista[i] < lista[i+1]:
        print(lista[i])

# 2. D√∫o de listas: suma por posici√≥n, ordenaci√≥n y sin duplicados

# Leer un entero m>0
while True:
    try:
        m = int(input('Introduce un entero m > 0: '))
        if m > 0:
            break
    except ValueError:
        print('Error, intente de nuevo')

# Capturar m enteros para L1
L1 = []
print('Introduce los elementos para L1:')
for i in range(m):
    while True:
        try:
            num = int(input(f'Elemento {i+1}/{m}: '))
            L1.append(num)
            break
        except ValueError:
            print('Error, intente de nuevo')

# Capturar m enteros para L2
L2 = []
print('Introduce los elementos para L2:')
for i in range(m):
    while True:
        try:
            num = int(input(f'Elemento {i+1}/{m}: '))
            L2.append(num)
            break
        except ValueError:
            print('Error, intente de nuevo')

# Generar LSUMA
LSUMA = [L1[i] + L2[i] for i in range(m)]

# Crear LORDENADA
LORDENADA = sorted(L1 + L2)

# Crear LUNICA
LUNICA = []
for num in LORDENADA:
    if num not in LUNICA:
        LUNICA.append(num)

# Mostrar ambas listas, su suma, la nueva lista en orden, y una sin repetir numeros
print(f'L1= {L1}')
print(f'L2= {L2}')
print(f'LSUMA= {LSUMA}')
print(f'LORDENADA= {LORDENADA}')
print(f'LUNICA= {LUNICA}')

# 3. Men√∫ de funciones: d√≠gitos faltantes, Fibonacci y combinaci√≥n de strings

# Opci√≥n 1: D√≠gitos faltantes (1‚Äì9)
def digitos_faltantes():

    t = int(input('Introduce la cantidad de d√≠gitos a ingresar (0 a 10): '))

    if not (0 <= t <= 10):
        print("La cantidad debe estar entre 0 y 10.")
        return

    # Guardar los d√≠gitos ingresados en una lista
    presentes = []
    if t > 0:
        print(f"Introduce los {t} d√≠gitos:")
        for _ in range(t):
            digito = int(input())
            presentes.append(digito)

    # Crear la lista de los faltantes
    faltantes = []
    for numero in range(1, 10):
        # Verificar si el n√∫mero no est√° en la lista de presentes
        if numero not in presentes:
            faltantes.append(numero)

    print('D√≠gitos faltantes (1-9):')
    for numero in faltantes:
        print(numero, end=' ')
    print()

# Opci√≥n 2: Serie de Fibonacci
def fibonacci():

    n = int(input('Introduce el n√∫mero de t√©rminos a generar (n >= 0): '))

    if n < 0:
        print("El n√∫mero no puede ser negativo.")
        return

    lista_fib = []
    a, b = 0, 1
    for _ in range(n):
        lista_fib.append(a)
        a, b = b, a + b

    print(lista_fib)

# Opci√≥n 3: Combinar listas de strings
def combinar_strings():
    a = int(input("Introduce la cantidad para L1: "))
    b = int(input("Introduce la cantidad para L2: "))

    if a <= 0 or b <= 0:
        print("Error: Las cantidades deben ser mayores a 0.")
        return

    l1 = [input(f"L1 - String {i+1}: ") for i in range(a)]

    l2 = [input(f"L2 - String {i+1}: ") for i in range(b)]


    l3 = []
    i, j = 0, 0
    while i < a or j < b:
        if i < a:
            l3.append(l1[i])
            i += 1
        if j < b:
            l3.append(l2[j])
            j += 1

    print("Resultados:")
    print(l1, l2, l3, sep='\n')


# Men√∫ principal
while True:
    print("1. D√≠gitos faltantes (1‚Äì9)")
    print("2. Fibonacci en lista")
    print("3. Combinar listas de strings")
    print("4. Salir del programa")
    opcion = input("Seleccionar el programa a ejecutar: ")

    match opcion:
        case '1':
            digitos_faltantes()
        case '2':
            fibonacci()
        case '3':
            combinar_strings()
        case '4':
            print("\n¬°Hasta luego! üëã")
            break
        case _:
            print("Opci√≥n no v√°lida. Por favor, elegir una opci√≥n del 1 al 4.")